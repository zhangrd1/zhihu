目标人群：美术、客户端或初级TA
方式：简明、宏观、系统
阅读时长：20min（）

# 01引言
- 最近开始从UE接触Unity，用一个mini项目为契机，入门了一下Unity编辑器的一些操作方式和Unity引擎的基本概念，正好最近项目接近结束，记录一下作为近期的学习成果
- 想来想去以渲染架构为主题，因为是游戏引擎的基本也是最重要的概念
- 在中外互联网检索了一下，分别聊UE和Unity的很多，但二者在一起聊的比较少，但可能无法，对比研究是很有用的。正好以Unity和UE（Unreal Engine）的渲染架构作介绍，并进行对比来明确二者的一些区别。
- 文章特点：不会深入技术细节，而是宏观上对二者进行一些区分有一些初步概念；

# 02引擎面临的共性问题
我一直有一个观点，就是所处的时间、空间相同，面临的问题是一致的，而都是地球上最聪明的大脑，方案只有差异没有优劣，只有取舍。所以在聊方案之前，聊聊面临的共性问题是很有必要的：
- 渲染质量与性能：在视觉效果和实时渲染性能之间找到平衡
- 多平台兼容：从移动设备到高端PC
![[Pasted image 20240820230532.png]]

- 目标客户：广泛的开发者群体，从独立开发者到AAA级工作室，能力不同

而接下来所讨论的，Unity和UE是如何针对这些问题，做出了不同的会赢。

# 03Unity渲染架构的原则与方案
虽然还没开始讨论，但刻板印象总是认为Unity注重灵活性和性能牺牲质量，而UE追求高画面品质牺牲性能和灵活性。我只只能说，刻板印象可耻但很有用。

Unity的渲染管线高度的灵活性和可定制性。

内置渲染管线、SRP,URP（Universal Render Pipeline）和HDRP（High Definition Render Pipeline）
![[Pasted image 20240820230849.png]]

## 内置管线（Build-in）
Build-in Render Pipeline 是Unity最早期的渲染架构，设计简单、易用，适用于各种设备，但灵活性和图形质量有限。（开箱即用）解决方案，它是一个高度封装的系统，用户无需对渲染管线有深入了解就可以使用。

虽然BiRP提供了相对较高的灵活性，例如允许在C#中通过回调更改渲染状态，但这导致了难以进行优化。尤其是当需要在帧中频繁切换状态时，这种灵活性会显著影响性能。BiRP的大部分配置是硬编码在C++中，无法轻松修改，这使得在不同硬件平台上进行优化变得困难。由于BiRP需要支持多种平台和API，因此其架构往往只能提供通用性能，而不能针对特定平台进行最佳化。同时，由于其允许在帧的任意阶段动态注入状态变更，缓存数据的效果变差，增加了性能开销。

尽管SRP是更现代化的架构，但由于BiRP在广泛项目中仍然被大量使用，因此Unity依然维持其支持，尤其是在那些已经投入生产的项目中。

BiRP虽然提供了较高的灵活性，允许用户通过C#回调在帧的任何阶段动态修改渲染状态，但这种灵活性也带来了性能问题。例如，动态切换对象的状态（如从刚体转换为蒙皮动画对象）会导致缓存失效和性能下降。

- BiRP中渲染算法和流程是固定的，虽然方便用户快速上手，但在一些特定情况下无法充分利用硬件特性，导致通用化的架构难以提供最佳的性能。

## SRP
BiRP的问题促使Unity开发了更灵活的SRP架构，Unity的核心引擎大部分仍然由C++编写，负责处理对性能要求极高的操作，如批处理、图形设备交互、内存管理、剔除操作和多线程任务分发。所有与性能高度相关的操作，尤其是涉及与GPU和图形API（如Vulkan、DirectX）的交互，均在C++层处理。

C#主要用于Unity的脚本化渲染管线（SRP）中，用户可以通过C#脚本来定义和控制渲染流程。例如，URP和HDRP的实现都主要基于C#。通过在C#层处理渲染逻辑，开发者可以快速迭代和修改渲染管线，而不需要重建整个引擎。
- RnederPass Abstraction
- Game-Logic Rendering Control

We probably need to iterate on the shader passes, render textures layout, etc. The heart and soul of the algorithm – and that’s where we want to spend our time, not the boiler-plate code in the layers below

Though occasionally, when shaders have very specific hardware dependency (VRS, instancing, tessellation, async compute), they need to reach to the engine or low-level API layers and may require deeper changes, in line with the corresponding shader changes. This is an infrequent operation, mostly when bringing up new hardware or API

- **快速迭代与热重载**：C#的使用使开发者能够在Unity编辑器中实现快速的参数调整和实时效果预览。这种“热重载”特性允许开发者无需重新启动引擎就能看到修改效果，从而加快开发速度。
- **安全性和稳定性**：C#作为高级语言提供了沙盒环境，用户层的代码即使崩溃也不会影响底层引擎。这种设计确保了引擎的稳定性。

通过将渲染控制权转移到C#层，使用户可以根据具体需求自定义渲染管线。SRP进一步分为URP（Universal Render Pipeline）和HDRP（High Definition Render Pipeline），分别用于普遍应用和高保真渲染。

优势：
- Componentize the steps of rendering via a concepts of building blocks you can put together, customize or extend
- Separate control of rendering order from the high throughput inner loops execution
- moved majority of iterative algorithm development into C# and shaders we can reap all the benefits of quick iteration with hot reload and parameter changes. 

- **Scriptable Render Pipeline（SRP）**：引入了可编程渲染管线，包括URP（通用渲染管线）和HDRP（高清渲染管线）。SRP让开发者可以更灵活地定制渲染流程，满足从移动端到高端设备的不同需求。

but shaders mostly need to agree just with C# layers (with the exception of high throughput instance data, which is still provided by C++ for performance reasons) which still need low-level exposure as before, for example, all instance data to shaders still comes from the C++ side: Transform matrices, light indices, reflection probe settings, light settings, layer settings, lightmap indices and UV rects, interpolated probe SHs, for faster setup). Table for all hardcoded C++ shader instance data: https://blogs.unity3d.com/wp-content/uploads/2019/02/Screen-Shot-2019-02-27-at- 3.50.52-PM.png

概述：URP是SRP的一个具体实现，旨在取代BiRP，成为Unity的默认渲染管线。它支持大多数平台，并且能够在不同硬件层级上提供良好的性能。HDRP是针对高保真渲染的SRP实现，主要用于高端平台，如PC和主机。它提供了一套丰富的特性，旨在实现次世代图形质量，例如物理基础渲染模型、复杂的光照和阴影效果、体积雾和光线追踪等。

目标：HDRP专为追求高保真图形效果的项目而设计，适用于AAA级游戏和需要逼真渲染效果的应用。虽然其自定义选项有限，但在支持的硬件上可以实现最佳性能。

SRP的引入展示了Unity向模块化、定制化方向的转变，反映了其在适应不同项目需求和性能优化上的努力。


同样支持PBR，但在灵活性和兼容性上做了更多折中

这一部分可以更加结构化，依次对比两个引擎在关键渲染模块（如光照系统、材质系统、后处理效果等）上的不同实现方案。这部分不需要太深入技术细节，但可以通过具体例子来体现设计哲学的差异，例如UE的“基于物理的渲染（PBR）”体系与Unity的灵活性之间的权衡。

虽然也提供了丰富的后处理选项，但更注重轻量化和可扩展性，开发者可以根据需要自定义管线。

相比Unity的Scriptable Render Pipeline（SRP），UE并没有像Unity那样提供完全可编程的渲染管线。但这种设计取舍是基于不同的市场需求：

Unity SRP：更适合需要高度定制渲染路径的开发者，特别是在移动平台或特殊需求下，SRP允许开发者从底层设计自己的渲染流程。

UE的统一架构：则更侧重于提供一套开箱即用的高质量渲染管线，且支持在此基础上的插件化扩展。这使得UE在3A游戏和电影制作中占据优势，因为这些场景需要稳定、高质量且一致的渲染表现。

![[Pasted image 20240820233834.png]]
The interface is designed such that you invoke a culling operation on the scene graph followed by a draw on the resultant list of scene nodes - specifying specific shader passes to draw with. Under the hood the engine will cull the scene graph in a jobified way and identify nodes that pass the culling and drawing parameters that are passed into the C++ low-level renderer architecture. Shaders can be designed for a particular render pipeline in mind


## URP+HDRP

## More
![[Pasted image 20240820234259.png]]
#### 资产接口（Asset Interface）
管理与渲染相关的资源和数据。它包括Material、Texture、Mesh、Shader等。这些资源在Unity Editor中创建，并被SRP用作渲染输入。负责将资源数据传递给渲染管线。



值得一提，它支持Unity已有的资源类型，使得从传统渲染管线迁移到SRP变得相对容易。例如，内置渲染管线中，着色器主要使用的是CG，在Scriptable Render Pipeline（SRP）——包括URP和HDRP——中，Unity逐步转向使用HLSL（High-Level Shading Language）

在内置管线中，着色器的通道通常由固定的渲染阶段组成，如“ForwardBase”、“ForwardAdd”、“ShadowCaster”等。这些通道由Unity内置渲染系统自动调用，开发者在编写着色器时往往需要遵循这些既定的命名规则，来确保不同阶段的正确渲染。

在SRP中，特别是URP和HDRP，着色器通道更为灵活。由于SRP允许完全自定义渲染流程，开发者可以根据需要定义任意通道名称和顺序。例如，开发者可以根据特定的渲染需求创建一个自定义通道用于处理某些复杂的后处理效果或光照计算。HLSL代码的每个通道都可以针对特定的渲染阶段进行高度优化，使得SRP中的着色器在可控性和效率上有了质的提升。

Constant Buffers（常量缓冲区）：
内置管线的CG着色器使用的是较为固定的常量缓冲区结构，这些缓冲区由Unity自动管理，如“UNITY_MATRIX_MVP”（模型-视图-投影矩阵）等。这些缓冲区的管理在传统管线中是“黑箱”式的，开发者的控制权有限。

在SRP中，常量缓冲区的设计可以更具针对性和可定制性。SRP中，开发者可以通过HLSL在每个渲染阶段定义自己所需的常量缓冲区，甚至通过CBUFFER（常量缓冲区）语法优化数据布局，减少GPU访问延迟。这使得开发者可以在性能敏感的场景中更精细地控制资源分配和使用，从而提升渲染效率。

算法与实现逻辑：
内置管线中的着色器大部分使用预定义的光照模型（如Blinn-Phong、Lambertian）和后处理效果，这些算法封装在Unity引擎中，开发者只能通过有限的选项进行调整。例如，Unity的Standard Shader就是基于这些固定的模型构建的，灵活性较低。

在SRP中，算法的实现完全由开发者掌控。URP和HDRP内置了一些现代的光照和渲染技术，如物理性基光照（PBR）、屏幕空间反射（SSR）、体积雾效等，但开发者也可以完全取代这些默认算法，编写自己的光照模型、阴影算法和渲染流程。SRP的这种可编程性使得高性能实时渲染和特殊视觉效果的实现成为可能。

数据类型的一致性与兼容性
虽然从语言（CG到HLSL）、着色器结构、算法复杂度到自定义渲染流程上都发生了变化，但材质、纹理、网格等数据类型在内置管线和SRP之间保持一致。原因在于，这些基础数据类型是Unity引擎的核心构造部分，为了确保向后兼容性和便捷的项目迁移，Unity保留了这些基本的接口设计。这样，开发者在将项目从内置管线迁移到SRP时，只需要重新编写或调整着色器内容，而不必大幅改动项目中已有的材质、纹理或网格数据。

#### SRP前端（SRP Frontend）
控制整个渲染管线逻辑，位于C#脚本层中。SRP前端负责定义渲染流程、控制渲染顺序以及管理渲染过程中的各种状态和参数。，包括剔除、排序、绘制、后处理等。URP和HDRP都是基于此前端实现的渲染管线。前端还包括配置选项，如选择前向渲染或延迟渲染等。

- **渲染管线的定义**：SRP Frontend 通过C#脚本定义渲染管线的逻辑，控制如何处理每一帧的渲染，包括光照计算、阴影生成、后处理效果等。Unity提供了两个默认实现：URP (Universal Render Pipeline) 和 HDRP (High Definition Render Pipeline)，开发者也可以自定义SRP。
- **渲染任务的调度**：SRP Frontend根据开发者定义的规则，调度渲染流程中的各个步骤。例如，在延迟渲染路径中，它会先渲染G-buffer，再进行光照计算和后处理。
- **灵活性与可扩展性**：SRP的可编程特性允许开发者为不同的项目需求定制渲染管线，从而在性能、视觉效果和资源使用之间找到最佳平衡。

#### 图形后端（Graphics Backend）
是SRP中的底层实现部分，负责执行高性能的渲染操作。它负责批处理、处理与GPU和图形API（如Vulkan、DirectX、Metal等）的交互，确保指令能够有效地传递到硬件层面。一切性能敏感
作用：该层包括批处理、剔除、设备交互和作业系统等。它以C++实现，并提供高吞吐量和低延迟的渲染路径。SRP的前端通过渲染上下文与图形后端交互，以实现具体的绘制操作。

Graphics Backend 是渲染管线中与底层图形API直接交互的部分，它将SRP Frontend中定义的渲染任务转化为具体的图形指令，提交给GPU进行执行。

- **图形API抽象**：Graphics Backend封装了不同平台上的底层图形API，如DirectX、Vulkan、Metal和OpenGL，使得Unity可以跨平台部署。无论是Windows、macOS还是移动设备，Graphics Backend都能够根据平台特点进行最优配置。
- **渲染命令的执行**：在渲染流程中，Graphics Backend负责执行所有低级别的渲染命令，如绘制调用（Draw Call）、状态设置和内存管理。它将SRP生成的渲染指令转化为特定平台的GPU指令。
- **性能优化与兼容性处理**：Graphics Backend在不同平台上进行适配和优化，例如处理多线程渲染、内存管理、资源同步等问题，以确保不同平台下的渲染效率和兼容性。

This layer consumes the authored asset data by processing instructions injected from the SRP frontend.

**LOD、Culling、SetupGoData 和 Renderer** 是更贴近Graphics Backend层次的概念，它们关注的是如何在具体渲染执行前准备和优化数据。

这些概念确实是在 Graphics Backend 中生效的，它们不再是资源定义和配置的阶段，而是进入了具体的渲染执行阶段。这里详细解释它们在 Graphics Backend 中的作用：

LOD (Level of Detail)

在 Graphics Backend 中，LOD 数据不是在渲染时实时计算的，而是在前一阶段的剔除和设置流程中被确定。具体来说：

LOD 的选择：在渲染前，系统会根据摄像机的距离、屏幕空间覆盖率等条件确定要使用哪个 LOD 级别。
在 Graphics Backend 中的作用：一旦 LOD 被选择，Graphics Backend 会直接处理选中的 LOD 网格和材质，将它们作为当前批处理的渲染目标。
Culling (剔除)

剔除是一个典型的 Graphics Backend 操作。剔除操作发生在渲染的早期阶段，直接影响哪些对象会进入渲染管线：

视锥剔除（Frustum Culling）：判断对象是否在摄像机的视野内。
遮挡剔除（Occlusion Culling）：判断对象是否被其他对象遮挡。
剔除的结果直接决定哪些对象的数据会被传递到 GPU 进行渲染。Graphics Backend 根据这些结果来生成优化的渲染指令，避免不必要的绘制调用。

SetupGoData (Setup GameObject Data)

SetupGoData 是 Graphics Backend 中的一个关键步骤，负责准备对象的渲染数据。这涉及将高层场景图中的信息（如物体的变换、材质配置、光照信息等）转换为 Graphics Backend 能够直接使用的数据格式：

在 Graphics Backend 中的作用：SetupGoData 完成数据准备后，Graphics Backend 可以直接访问和使用这些数据进行渲染。它确保了在渲染过程中，所有对象的数据（例如变换矩阵、材质、光照设置等）都已正确配置。
Renderer (渲染器)

Renderer 是 Unity 场景图和 Graphics Backend 之间的桥梁。它在渲染时起到了关键的管理和组织作用：

在 Graphics Backend 中的作用：Renderer 组件会将所有需要渲染的对象信息传递给 Graphics Backend，Graphics Backend 然后将这些对象的资源绑定到渲染流水线上。比如，在批处理中，Renderer 负责确保相同材质的对象被合并在一起，从而减少 Draw Call 的数量。

Renderer 是 Unity 中的一个核心组件，负责将对象的网格、材质、光照等信息与渲染管线关联起来。常见的渲染器组件包括MeshRenderer、SkinnedMeshRenderer等。

在Graphics Backend中的实现：

Renderer 会根据场景图中的设置，管理对象的可见性、光照影响、阴影投射等信息。
在渲染过程中，Renderer 组件会根据场景状态自动绑定必要的数据（如网格、材质、实例ID等）到具体的渲染批次中。

在Graphics Backend中的实现：

LOD系统通常在场景图更新和剔除过程中被处理。在这些过程中，Unity根据视图距离和预定义的LOD规则选择合适的模型。
选定的LOD模型数据（例如网格和材质）会作为实例数据传递给渲染管线。这些数据成为渲染过程中需要绑定的资源之一。
剔除是渲染中的重要步骤，用来决定哪些对象需要被渲染，哪些可以被忽略。常见的剔除类型包括视锥剔除（Frustum Culling）、遮挡剔除（Occlusion Culling）等。

在Graphics Backend中的实现：

剔除操作会在场景图更新时触发，通过判断物体是否在摄像机的视野内（或是否被其他物体遮挡），剔除不需要渲染的对象。
剔除后的可见对象列表会被传递给渲染管线，进入批处理阶段。这些可见对象的数据（如变换矩阵、材质等）会被整理并绑定到具体的渲染指令中。
SetupGoData 是 Unity 渲染管线中的一个内部步骤，用于准备与渲染相关的 GameObject 数据。这个步骤确保在渲染过程中，所有需要的实例数据都已被正确配置和绑定。

在Graphics Backend中的实现：

SetupGoData 涉及对对象的渲染状态、变换矩阵、材质属性等进行设置，确保这些数据在批处理中可以被正确使用。
这个过程还包括设置光照、阴影信息，以及LOD数据的选择等。

5. SRP api
在通过SRP API执行渲染时，必须指定你想要绘制的具体“通道名称”。这就是SRP与着色器渲染之间的连接。

these assets are data types that live in our graphics backend which are then attached to nodes on our scene graph. This means we have access to them at render time. 

渲染资产（如材质、网格、纹理）并不直接存在于场景图中，而是以引用的方式附加到节点（如GameObject）上。具体来说：

MeshRenderer组件会引用一个网格（Mesh）和一个或多个材质（Material）。
材质又会引用具体的着色器（Shader）和与之相关的纹理（Texture）数据。
当场景图被渲染时，渲染管线会遍历这些节点，并根据附加的资产信息生成绘制指令。例如，当渲染一个带有MeshRenderer的GameObject时，系统会根据该对象附加的网格、材质、纹理和其他属性，在适当的渲染阶段（如不透明物体、透明物体等）执行绘制。

4. 渲染时的数据访问与处理
渲染过程发生在场景图遍历和剔除操作之后。此时，渲染管线会根据各个节点的配置，访问并绑定所需的图形数据类型到GPU。例如：

在绘制调用（Draw Call）中，网格的顶点数据会被发送到GPU的顶点着色器进行处理。
材质中的纹理和着色器参数会被设置到GPU，以便在片元着色器中进行光照计算和像素处理。
在SRP中，这个过程更加灵活，开发者可以自定义具体的渲染顺序和策略。例如，可以通过RenderContext来控制哪些对象按何种顺序被渲染，并在渲染之前绑定所需的资源。

5. 数据与渲染流程的集成
这种架构的优势在于：

实时访问与动态更新：由于资产在场景图中是通过引用关联的，这些数据可以在运行时动态更新。例如，材质的参数可以通过脚本在运行时改变，实时影响渲染效果。
资源重用与优化：多个场景节点可以共享同一个材质或纹理，避免重复加载资源。这在批处理（Batching）和减少Draw Call方面非常重要，有助于提高性能。
可扩展性：开发者可以在SRP中自定义数据处理逻辑，扩展或优化渲染管线，而无需修改底层的图形后端实现。

 This is also where our scene graph lives and many of the operations invoked on the SRP API trigger batch processing operations to this scene graph. 

在SRP架构下，场景中的物体并不是直接渲染的，而是通过场景图来组织和管理。渲染操作通常涉及对场景图中的节点进行遍历和处理，而这些处理操作往往以批处理的形式进行。具体来说，SRP API 会触发对场景图的操作，例如剔除（Culling）、排序、分组等，这些操作最终会生成一组需要进行渲染的对象列表。

批处理操作是Unity提高渲染性能的重要机制之一。在渲染过程中，多个具有相似属性的对象可以被组合成一个批次进行绘制，从而减少Draw Call的数量，提升渲染效率。场景图在这个过程中扮演了重要角色。

具体来说，SRP API 调用后，场景图中的节点会根据其渲染属性（如材质、着色器、透明度等）进行分组。例如，所有使用相同材质的对象可以被归为一个批次进行处理。在渲染时，SRP根据这些分组生成批处理指令，发送给图形后端（GPU），从而减少了冗余的状态切换和绘制调用。


在SRP中，以下操作通常会触发对场景图的批处理：

剔除（Culling）：根据摄像机视角，场景图中的节点会被剔除掉不在视野中的对象，只保留需要渲染的节点。
排序（Sorting）：场景图中的节点会按照透明度、深度、材质等属性排序，确保正确的渲染顺序。
合并（Merging）：将共享相同材质和着色器的对象合并到同一批次中。
这些操作都是通过对场景图进行遍历和处理来实现的，最终生成批次信息并交给GPU进行渲染。

5. 具体实现：SRP中的场景图处理
在SRP中，开发者可以通过RenderContext和其他API直接与场景图交互，获取需要渲染的节点信息。RenderContext中的剔除和渲染操作会遍历场景图，过滤出有效的渲染对象，并将其组织成批次。例如：

开发者可以通过SRP API调用剔除操作，获取当前视野中的渲染节点。
获取这些节点后，可以根据不同的渲染阶段（如不透明物体、透明物体）将节点分类，生成需要绘制的批次。
这些批处理操作在SRP API层面抽象出来，开发者可以自定义如何组织和处理场景图中的数据，灵活控制渲染流程。

在Unity的Scriptable Render Pipeline (SRP) 中，有一系列常用的API用于自定义渲染管线。这些API主要集中在以下几个方面：渲染流程控制、资源管理、图形设置和渲染状态管理。下面是一些在SRP中常用的API及其作用：

1. ScriptableRenderContext
这是SRP的核心类之一，负责与底层渲染管线进行交互，控制渲染过程。通过ScriptableRenderContext，你可以访问和管理场景中的渲染信息，执行各种渲染命令。

常用方法：

DrawRenderers(): 用于绘制场景中的渲染器（Renderers），可根据不同的渲染阶段（如不透明、透明）来过滤和排序对象。
Cull(): 执行剔除操作，返回当前视野中的可见对象列表。
ExecuteCommandBuffer(): 执行命令缓冲区中的渲染命令。
Submit(): 提交所有已添加到上下文中的渲染指令并进行渲染。
2. CommandBuffer
CommandBuffer是一个重要的工具，用于在渲染过程中收集并存储一系列渲染指令，然后批量执行。这有助于优化性能并允许精细控制渲染流程。

常用方法：

SetRenderTarget(): 设置当前渲染目标（如颜色缓冲区、深度缓冲区）。
ClearRenderTarget(): 清除渲染目标的内容。
DrawMesh(): 绘制指定的网格。
Blit(): 将源纹理复制到目标渲染目标，可以用于后处理效果。
3. CullingResults
这是剔除操作的结果，包含了可见对象的列表。在进行渲染时，使用这些结果来决定哪些对象需要绘制。

常用方法：

GetRenderers(): 获取剔除结果中的可见渲染器列表。
GetVisibleLights(): 获取可见的光源列表。
GetShadowCasterBounds(): 获取用于阴影绘制的光源的边界。
4. DrawingSettings
DrawingSettings用于控制如何渲染对象，包括着色器通道的选择、排序规则等。

常用属性和方法：

perObjectData: 指定在每个对象上渲染时需要的额外数据（如光照信息、反射探针等）。
sortingSettings: 指定对象渲染的排序规则（如从前到后、从后到前等）。
overrideMaterial: 设置渲染时使用的材质，可用于调试和特定渲染阶段。
5. FilteringSettings
FilteringSettings用于定义哪些对象应该被渲染，通常结合DrawingSettings使用。

常用属性：

renderQueueRange: 设置渲染队列的范围，用于过滤不同类型的对象（如不透明、透明对象）。
layerMask: 用于指定渲染层，决定哪些层中的对象会被渲染。
renderingLayerMask: 用于更细粒度的对象过滤。
6. RenderTargetIdentifier
这个类用于标识渲染目标，如颜色缓冲区、深度缓冲区、纹理等。它可以传递给各种渲染方法。

常用场景：

设置和切换不同的渲染目标。
将渲染结果输出到特定的纹理或帧缓冲。
7. RenderPipelineAsset & RenderPipeline
自定义渲染管线的核心，开发者需要继承RenderPipelineAsset和RenderPipeline来创建自己的渲染管线。

常用方法：

Render(): 这是自定义管线的主入口，每一帧都会调用，负责整个渲染流程。
Dispose(): 用于释放资源，当渲染管线被销毁时调用。
8. LightDataGI & Lightmapping
这些API主要用于管理全局光照和光照贴图，特别是在自定义光照模型和烘焙过程中。

常用场景：

配置光照数据，控制光照贴图的生成和应用。
自定义光照贴图的处理和合并。
9. ShaderTagId
ShaderTagId用于指定着色器通道（Shader Pass）。在SRP中，开发者可以使用ShaderTagId来控制在渲染不同对象时使用的具体着色器通道。

常用场景：

自定义对象渲染时选择不同的渲染通道，如阴影、透明度等。
10. RendererList
RendererList用于定义和存储一组渲染器，这些渲染器将在指定阶段被渲染。它允许开发者批量管理和优化渲染对象。

常用场景：

在特定阶段，如不透明对象的渲染、阴影绘制时，组织一组对象并进行高效渲染。
总结
这些API构成了SRP自定义渲染管线的基础，帮助开发者精细控制渲染流程、管理资源、优化性能。通过这些API，开发者可以实现高度定制化的渲染效果，满足不同的项目需求。

3. 渲染上下文（Render Context）
概述：渲染上下文是SRP中连接C#脚本和底层C++渲染核心的桥梁。它提供了一组API，使开发者能够从C#层控制底层渲染命令的执行。
作用：渲染上下文主要用于组织和管理渲染任务。通过渲染上下文，开发者可以对渲染操作进行批处理，如指定需要绘制的对象、定义渲染排序、设置着色器通道等。渲染上下文确保了高效的批量处理和资源绑定，提升了渲染性能。

. We converged on solution that allows for higher level rendering flow to be controlled from c#, but draws to be controlled as batches. Essentially post culling we would have a list of all valid RenderNodes and be able to say: “Render the opaque ones front to back” or “Render the transparent ones back to front”. This allows for rendering control flow to live in c# 

this was called the RenderContext - This is a proxy object that lives within our c++ layer but has a binding layer into c# - Holding this object allows access to our rendering API.

![[Pasted image 20240821002535.png]]
这是上下文中可以进行的操作的粒度



5. 渲染流程（Rendering Workflow）
概述：渲染流程是开发者定义的SRP实际工作流程，包括各个渲染阶段的顺序和逻辑。这一流程由开发者在C#层定制和控制，通常包含以下主要步骤：
剔除（Culling）：决定哪些对象在当前帧中可见。
排序（Sorting）：确定对象的绘制顺序，如不透明物体从前到后绘制、透明物体从后到前绘制。
绘制（Rendering Passes）：执行实际的绘制命令，包括多次渲染通道，如阴影、光照、后处理效果等。
后处理（Post-Processing）：应用如颜色调整、模糊、抗锯齿等效果。



# 04UE渲染架构的原则与方案

UE的渲染架构设计理念以“统一集成、高质量默认配置”作为主导。与Unity SRP的“从底层完全可编程”的设计理念形成了鲜明对比。

UE的线程（FRunnableThread）

- 游戏线程（Game Thread）（也称作主线程）（UGameEngine::Tick）
- 渲染线程（FRenderingThread）
    - 专门用于生成渲染指令 (FRenderCommand) 和渲染逻辑的独立线程
- RHI线程（RHI Thread）
    - 转换渲染指令到指定图形API，创建、上传渲染资源到GPU
    - **RHI**全称是**Render Hardware Interface（渲染硬件接口）**, 封装了众多图形API（DirectX、OpenGL、Vulkan、Metal）之间的差异

UE渲染架构的重要特点之一是它对多线程和并行处理的支持。

渲染线程与游戏线程的分离：UE中，渲染线程与游戏线程是分离的，这种设计确保了在处理复杂场景时，渲染可以最大限度地利用硬件资源而不被游戏逻辑阻塞。游戏线程生成的渲染命令被传递给渲染线程，渲染线程再将这些命令进行优化并发送给底层的图形API。
任务调度与并行渲染：UE使用了任务系统来实现渲染的并行处理。任务系统能够将不同的渲染任务分配到不同的CPU核心上进行处理，如光照计算、阴影生成等。这样做极大提高了渲染的效率，尤其在多核处理器环境中表现尤为显著。

其中游戏线程负责资源加载合场景搭建，渲染线程负责剔除、渲染管线，RHI负责生成指令提交GPU渲染。

UE5
- RHI层的变动主要在于将各种顶点、索引Buffer统一成了FRHIBuffer。
- Renderer层增强了光线追踪，特别是屏幕空间的光线追踪，加强了距离场的各种应用，同时删除了LPV。
- Engine层主要围绕着RHI、Renderer层的变动做了相应修改和调整

基于物理的渲染（PBR）体系与先进的动态光照和GI（全局光照）系统。
内置了电影级别的后处理效果，如深度景深、运动模糊和镜头光晕，优化路径针对高端平台。

- **UE3及以前**：早期版本以固定渲染管线为主，适合当时的硬件性能和游戏开发需求，但灵活性不足。
- **UE4的全面转型**：引入现代的基于物理的渲染（PBR）和全局光照系统，带来了强大的实时渲染能力，特别是对光照和材质的逼真表现。
- **UE5的Nanite和Lumen**：进一步提升了渲染架构，Nanite提供了虚拟几何体技术，允许超高细节模型实时渲染，Lumen则是动态全局光照系统，彻底改变了光照的表现方式。
- **设计哲学**：UE的演变展现了其“高保真、高质量”的设计理念，从早期到最新版本都在追求顶尖的视觉效果。

UE4的发布标志着UE渲染架构的重大转型，核心特征包括：

基于物理的渲染（PBR）：这是UE4渲染架构的基础。PBR提供了更真实的光照和材质表现，结合实时全局光照、动态阴影和高级的后处理效果，支持开发出视觉效果极佳的3A游戏。
可扩展渲染架构：UE4在底层架构上设计了模块化的渲染组件，虽然不像Unity的SRP那样允许高度自定义，但UE4提供了丰富的渲染选项，开发者可以通过材质系统、光照模型和渲染设置调整最终效果。
渲染路径：UE4内置了多种渲染路径，包括延迟渲染（deferred rendering）和前向渲染（forward rendering），根据项目需求进行选择。

3. Nanite和Lumen引擎技术的引入（UE5）
UE5对渲染架构主要体现在：
Nanite虚拟化几何体技术：Nanite通过细节层次（LOD）自动处理，使得引擎可以无缝渲染高细节的几何体，无需手动优化。它有效简化了资产管理并显著提升了大型场景的渲染效率。
Lumen动态全局光照系统：Lumen使得实时的全局光照和反射成为可能，无需烘焙光照信息，极大地提升了场景的动态表现能力。这种全局光照系统在电影级别和高保真游戏中表现尤为出色。

插件和扩展：虽然UE的渲染路径相对固定，但通过插件和定制模块，开发者可以在UE的渲染架构上进行个性化扩展，添加自定义的渲染效果或优化方案。

a. 统一的核心渲染路径
Unreal Engine采用了统一的核心渲染路径，即无论是延迟渲染还是前向渲染，都是在一套高度集成的架构下进行的。这个架构的核心设计理念是提供一个高质量的默认配置，使得即便在不进行深度定制的情况下，开发者也能够获得优异的视觉效果。

这种架构设计避免了类似Unity的多套完全独立管线（如Built-in、URP、HDRP）的繁琐管理，而是在同一套架构下进行不同渲染路径的选择与切换。这让开发者可以基于项目需求进行调整，而不需要在多个架构之间迁移​ (Epic Games Developer)。

b. 模块化和可扩展性
虽然UE的渲染管线不像Unity SRP那样允许开发者从底层完全自定义渲染流程，但它依然通过插件系统、HLSL着色器编写和源码扩展，提供了广泛的定制能力。开发者可以在现有架构基础上插入自定义的渲染阶段或替换默认的渲染路径。

这一点使得UE在保持高质量默认配置的同时，也具备了灵活适应不同场景的能力。这种“高集成性与可定制性”的设计哲学使得UE可以更好地平衡通用性与特殊需求​ (Unreal Engine)​ (Epic Developer Community Forums)。

c. 集成化设计
UE的渲染架构高度集成，贯穿了材质系统、光照系统、后处理效果等各个层面。这种集成不仅体现在功能上，也体现在开发流程上。例如，UE的材质系统与渲染架构紧密结合，使得开发者可以直接在高层次的材质编辑器中对底层渲染进行微调，而不需要编写大量低层代码​ (Unreal Engine)。


1. 输入资源与资源管理
FRHIResource：FRHIResource 是所有图形资源的基类，包括纹理、缓冲区等。它抽象了跨平台资源管理，使得渲染资源能够在不同图形API上保持一致性​ 。
这些输入资源由场景（FScene）和视图（FView）进行组织和管理。场景包含所有的可渲染对象和光源，而视图则负责描述如何观察场景，包括摄像机位置、投影矩阵等信息。

2. 渲染处理与优化
渲染流程的核心由渲染器（如FDeferredShadingSceneRenderer）控制。其职责是组织并执行一系列渲染步骤（Pass），这些步骤根据需要被高度优化：

延迟渲染（Deferred Shading）：UE中广泛使用延迟渲染，它将几何信息存储在G-buffer中，然后在独立的光照Pass中计算光照。FDeferredShadingSceneRenderer管理这些Pass的执行顺序，包括阴影、光照和后处理等步骤​ (玄冬Wong)​ (Unreal Art Optimization)。
Custom Render Passes：UE允许开发者自定义渲染通道，在标准渲染流程中插入自定义逻辑，例如特殊的视觉效果或调试工具。通过实现自定义的全局Shader并扩展渲染器，开发者可以灵活定制渲染管线​ (Epic Dev | Home)​ (GitHub)​ (Epic Developer Community Forums)。
多线程与任务调度：渲染流程中的计算任务通过多线程进行调度。UE使用任务系统在多个CPU核心上并行处理不同的渲染任务，如光照计算、阴影生成等，以提升渲染效率。
3. 与图形API的交互
渲染器生成的指令通过抽象的图形硬件接口（RHI）与底层图形API交互，这一层是UE跨平台渲染的核心：

FRHICommandList：该类是渲染指令的核心调度器，负责批量管理和提交所有的渲染命令，如绘制调用、资源状态切换等。这种批处理机制不仅提高了性能，还允许在不同平台上使用统一的渲染逻辑​ (Epic Games Developer)。
跨平台抽象与优化：RHI模块为不同平台提供特定实现（如DirectX、Vulkan、Metal），确保高层渲染逻辑的跨平台兼容性。同时，开发者可以在平台特定的RHI模块中进行优化，以最大化利用平台特性。




UE的渲染架构的设计哲学是基于模块化和抽象的。这种设计允许开发者在不需要修改底层代码的情况下，扩展或替换渲染管线的部分功能。同时，UE也提供了大量的默认实现和扩展点，以满足不同项目的需求。

关键理念包括：

- **模块化设计**：渲染系统被划分为多个独立模块，如渲染管线、材质系统、光照系统等，各模块之间通过接口和抽象层进行交互。
- **层次化架构**：从高层次的渲染控制到底层的硬件交互，UE的架构设计具有清晰的层次分工，每层都对上一层提供服务，同时对下一层进行抽象。
- **可扩展性与可插拔性**：开发者可以通过继承和接口扩展UE的渲染功能，甚至替换默认实现。


- 高层控制
负责渲染流程的总体调度和管理，包括场景管理、帧生成以及渲染器调度。主要由`FScene`, `FView`, `FSceneRenderer`等核心类构成。
- **FScene**：负责管理和存储场景中的数据（对象、光源、材质等），提供渲染所需的基础信息。基本功能包括：
	- 场景数据的组织与管理：FScene维护场景中所有可渲染对象的状态，并提供接口用于查询和访问这些对象。
	- 渲染线程与游戏线程的同步：FScene 在游戏线程中被更新，但渲染线程需要读取场景数据，因此它也处理两者之间的同步工作。
	- 此外，FScene 并不仅仅是一个数据容器，它还包含一些与场景管理相关的逻辑，例如灯光信息的管理和对象的可见性计算​。

- **FView**：管理摄像机参数、可见性、投影矩阵等信息。
	- 视图设置与状态：FView 包含了视角、屏幕分辨率、场景可见性等数据，这些信息会影响场景的渲染方式。
	- 投影计算：在渲染过程中，FView 的矩阵信息被用于将场景从世界坐标系转换到屏幕坐标系。
	- 多视图支持：在一些复杂场景中（如VR或多摄像机视图），会有多个 FView 实例，每个实例对应一个独立的视图。

- **FSceneRenderer**：负责渲染管线的调度和执行，是渲染流程的主要入口。不同的渲染器（如延迟渲染器、移动渲染器）都继承自该类，封装了具体的渲染流程。
	- 渲染流程控制：FSceneRenderer 定义了渲染的主要步骤，如G-buffer生成、光照计算、阴影渲染和后处理效果。
	- 视图与场景的结合：在每一帧中，FSceneRenderer 会结合多个 FView 实例和一个 FScene，决定如何渲染场景中的每个对象。
	- 渲染任务的调度与优化：FSceneRenderer 还处理渲染任务的排序和优化，如批处理、透明度处理等，以确保高效渲染​。
	- 不同的渲染器（如延迟渲染器、前向渲染器）都可以通过继承并实现该接口，从而插入自定义的渲染逻辑。


- 渲染管线层
负责具体的渲染流程，通常由不同的渲染管线组成，如延迟渲染、前向渲染等。UE的渲染管线通过多个Pass组织，如阴影Pass、反射Pass、后处理Pass等。
- **FDeferredShadingSceneRenderer**：这是UE延迟渲染的核心实现，控制G-buffer的生成、光照计算、后处理等步骤。
	- 渲染流程的核心控制：在每一帧渲染中会通过调用其Render函数来执行整个延迟渲染过程。这个过程包括从生成G-buffer到最终光照计算和后处理的所有阶段。
	- 渲染通道的管理：FDeferredShadingSceneRenderer通过一系列的渲染Pass组织渲染工作，比如阴影Pass、光照Pass和后处理Pass等。这些Pass按照特定顺序执行，以确保最终的图像输出。
	- 与Post Processing集成：FDeferredShadingSceneRenderer还负责管理和触发后处理效果，如景深、运动模糊和色调映射等。这些效果通常在渲染完场景的基础光照之后执行​ 。

- **Custom Render Passes**：UE允许开发者通过自定义渲染通道来插入或替换特定渲染阶段，提供了很大的灵活性。自定义渲染通道通常用于在默认的渲染流程中插入额外的渲染逻辑，比如特效、屏幕空间效果或调试工具。关键点包括：
	- 渲染流程的扩展：开发者可以在现有渲染通道之前、之后甚至在中间插入自定义的Pass。例如，可以在所有后处理效果之前插入一个自定义Pass，用于计算额外的屏幕空间效果。
	- 全局Shader与自定义绘制：通过使用全局Shader和低级渲染接口（如FRHICommandList），开发者可以在自定义Pass中实现复杂的效果。比如，可以在特定渲染阶段执行额外的几何绘制，或处理特定的纹理效果​ 。
	- API支持与灵活性：引擎为自定义渲染通道提供了灵活的API支持，开发者可以通过继承或重写现有的渲染类，插入自定义逻辑。具体实现方式通常包括注册新的渲染通道，并在渲染流程中动态调用这些通道​。


- 中层抽象与API交互层
UE的设计通过接口和抽象类，使得渲染管线与具体的图形API解耦。渲染管线的各个Pass生成的渲染指令会通过这些接口发送到硬件。
- **FRHICommandList**：这是UE与底层图形API交互的主要接口。所有的渲染指令都会通过`FRHICommandList`发送到硬件。这种设计确保了UE能够支持多种图形API。用于在渲染过程中调度和管理图形命令。这些命令可以包括绘制调用、资源绑定、状态设置等。其主要作用包括：
	- 命令缓冲区：FRHICommandList 充当命令的缓冲区，在一帧中累积所有渲染指令，并最终在适当的时机将它们提交给GPU。这种设计使得渲染指令可以被批量处理，从而提高性能
	- 多线程支持：它支持在多个线程上生成渲染命令，这使得渲染任务能够高效并行处理，最大化利用硬件资源。
	- 资源过渡管理：FRHICommandList 还管理资源状态的转换（如从读到写的转换），确保资源在不同阶段被正确使用。

- **FRHIResource**：代表渲染资源的抽象，如纹理、缓冲区等。它们被封装在这一层中，以确保跨平台一致性。FRHIResource 是所有RHI（Render Hardware Interface）资源的基类，包括纹理、缓冲区、渲染目标等。其主要职责包括：
	- 生命周期管理：FRHIResource 负责管理资源的创建、引用计数和释放，确保资源在正确的时间被分配和销毁。
	- 跨平台抽象：通过统一的资源接口，FRHIResource 允许引擎在不同的平台上进行渲染，而不需要关心底层API的实现细节。
	- 资源类型扩展：开发者可以基于FRHIResource扩展新的资源类型，满足特定的渲染需求​ (Epic Games Developer)​ (Epic Games Developer)。




- 底层图形API与硬件层
这一层是UE直接与图形硬件和操作系统交互的部分。它负责管理硬件资源、处理平台特定的优化、执行渲染指令。
- **DirectX, Vulkan, Metal 等API**：UE通过不同的RHI（Render Hardware Interface）模块来支持多种图形API。每个RHI模块实现了特定平台的渲染指令，确保在不同平台上都能高效运行。

底层硬件交互主要由RHI模块实现，使得上层逻辑可以与硬件细节解耦。

**中层抽象层**与**底层图形API层**通过特定的RHI模块（如DX11、Vulkan RHI）进行连接。这确保了UE在不同平台上的渲染逻辑可以一致，而底层实现则由特定平台的RHI处理。







### 4. **扩展性与可插拔性**

UE的架构在多个层次上提供了扩展点，允许开发者插入、替换或自定义渲染流程：

- **渲染管线扩展**：开发者可以通过继承`FSceneRenderer`实现自定义的渲染管线，甚至完全替换默认的延迟渲染流程。
- **渲染阶段插入**：通过自定义的Render Pass，开发者可以在现有的渲染管线中插入自定义逻辑，如特效处理、额外的光照计算等。
- **平台扩展与优化**：通过RHI模块，开发者可以针对特定平台进行底层优化，甚至添加对新图形API的支持。
































Shader Pipeline & Material System：UE的Shader系统是高度模块化的，使用HLSL进行编写，并通过Material Editor以节点图的方式直观呈现。UE中的Material系统不仅支持物理材质，还能通过自定义Shader和复杂的材质表达式进行扩展。
Rendering Policies & Strategies：通过可配置的渲染策略，UE允许开发者根据项目需求调整渲染过程。例如，可以自定义渲染排序策略、裁剪策略、光照策略等。这些策略由高层的渲染控制器管理，并在每一帧渲染时动态选择。
4. RHI（Render Hardware Interface）与多平台支持
UE的RHI（渲染硬件接口）是一个关键的抽象层，允许引擎在不同平台上保持一致的渲染行为。





插件与模块化扩展：通过插件机制，开发者可以为UE添加自定义渲染功能。渲染器可以作为模块独立开发，甚至可以完全替换默认的渲染管线。UE5中的许多新功能（如Nanite、Lumen）都是以模块形式实现的，这使得功能开发和迭代变得更加独立和灵活。
自定义Shader与后处理管线：开发者可以通过继承和扩展现有的Shader和后处理框架，实现特定需求的视觉效果。后处理管线的灵活性使得开发者可以在现有渲染流程中插入自定义效果，例如特殊的色调映射、屏幕空间反射等。

## UE延迟渲染管线
- **延迟渲染（Deferred Rendering）**：这是UE4及以后版本的默认渲染管线，主要用于处理复杂的光照和材质效果。延迟渲染将几何体信息和光照分离，允许场景中有大量的动态光源而不会显著影响性能。这非常适合高端、光照复杂的场景。



## 扩展
- **自定义渲染路径（Custom Rendering Path）**：虽然不像Unity的SRP那样模块化，但UE支持通过修改引擎源码或使用渲染插件自定义渲染路径。例如，一些工作室会为特定的光照模型或材质效果自定义渲染管线，以满足项目的特殊需求。

虽然UE的渲染管线不像Unity的SRP那样模块化，但开发者可以通过以下方式实现自定义和扩展：

- **HLSL着色器**：UE支持在材质系统中直接编写HLSL代码，进行底层的自定义着色器开发。
- **渲染插件与引擎源码扩展**：UE的开源特性允许开发者修改引擎底层代码，创建定制化的渲染路径或效果。许多高级工作室会基于这一能力，为项目需求打造高度优化的特定渲染模块。

自定义Pass与Render Queue
自定义渲染Pass：UE允许开发者通过扩展引擎的渲染管线，插入自定义的渲染Pass。例如，开发者可以在G-Buffer阶段之后插入自定义的着色器效果，或在光照阶段添加额外的光照计算。通过继承和扩展引擎中的FDeferredShadingSceneRenderer类，开发者可以定义自己的渲染步骤。

渲染队列（Render Queue）与命令列表（Command List）：UE的渲染架构中，所有渲染操作都是通过命令列表管理的。开发者可以在渲染过程中自定义命令，将特定任务添加到渲染队列中。这种方式为实现定制化渲染路径提供了灵活性。


Shader Permutations：为了优化渲染性能，UE会根据不同的渲染条件生成着色器的多种变体（Permutations）。在自定义渲染中，开发者可以定义新的条件或开关，生成新的着色器路径，以适应不同的设备或项目需求。

引擎源码修改与插件扩展
引擎源码修改：对于需要深度定制的项目，UE的开源特性允许开发者直接修改引擎源码，例如创建新的渲染路径或自定义G-Buffer结构。这种方式在一些高度优化的项目中非常常见，特别是当默认的渲染管线无法满足特殊需求时。

插件扩展：UE的插件系统允许通过模块化的方式添加自定义渲染功能。开发者可以创建独立的渲染模块，插入到引擎的渲染管线中。例如，一些光照插件或渲染优化插件就是通过这种方式集成的。

# 05对比与讨论
在总结两者的架构异同时，除了直接对比它们的优劣，可以引入不同开发者场景中的实际需求（例如AAA游戏 vs. 独立游戏开发）来讨论两者在不同情境下的适用性，这样可以让讨论更加具备实用价值和前瞻性。

总结两者的优劣，提出在未来不断演进的游戏开发需求下，Unity和UE可能会如何继续调整各自的渲染架构设计。

实时光线追踪、混合渲染、云渲染等新兴技术如何影响UE和Unity的渲染架构。

最后一个部分可以总结一下当前技术趋势（如实时光线追踪、混合渲染等）对Unity和UE渲染架构的潜在影响，并探讨这两款引擎在未来可能的演进方向。这不仅能够呼应文章开头的行业共性问题，还能为文章提供更具深度的结论。










渲染管线设计原则：
![[Pasted image 20240819103548.png]]

Build-in 管线
![[Pasted image 20240819104134.png]]
![[Pasted image 20240819104207.png]] 

Deferred Rendering：第一个pass填充Gbuffer，第二个pass执行Lighting
![[Pasted image 20240819215612.png]]

Unity提供了宏来帮助Mobile进行读取Buffer

没看懂
![[Pasted image 20240819220228.png]]

没看懂
![[Pasted image 20240819220954.png]]


[SIGGRAPH 2021 REAC: Unity Rendering Architecture (youtube.com)](https://www.youtube.com/watch?v=6LzcXPIWUbc)
[Unity Scriptable Render Pipeline（一） - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/460780649)
[SIGGRAPH 2021 REAC: Unity Rendering Architecture - YouTube](https://www.youtube.com/watch?v=6LzcXPIWUbc)
[现代图形引擎入门指南（十五）— 渲染架构 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/659774241)











[UE管线图解 - 渲染 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/640554450)
[UE渲染源码剖析 - Heskey0 - 博客园 (cnblogs.com)](https://www.cnblogs.com/Heskey0/p/16182731.html)
[虚幻引擎UE渲染框架 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/484960867)
[Unreal 渲染管线原理机制源码剖析 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/641367884)
[Re：从零开始的UE渲染学习-1开篇预览 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/680266148)
[UE5渲染管线概览 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/508372052)
[UE5中的卡通渲染——自定义描边Pass - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/597864516)
[Pushing Next-Gen Real-Time Technology in Marvel 1943: Rise of Hydra | GDC 2024 (youtube.com)](https://www.youtube.com/watch?v=PRc_Vy-W0yw)



[Begin Play | Rendering | Epic Developer Community (epicgames.com)](https://dev.epicgames.com/community/learning/tutorials/vyZ1/unreal-engine-begin-play-rendering)

[Optimizing UE5: Rethinking Performance Paradigms for High-Quality Visuals - Part 1: Nanite and Lumen | Unreal Fest 2023 | Epic Developer Community (epicgames.com)](https://dev.epicgames.com/community/learning/talks-and-demos/Vpv2/unreal-engine-optimizing-ue5-rethinking-performance-paradigms-for-high-quality-visuals-part-1-nanite-and-lumen-unreal-fest-2023)

[Optimizing UE5: Rethinking Performance Paradigms for High-Quality Visuals - Pt 2: Supporting Systems | Unreal Fest 2023 | Epic Developer Community (epicgames.com)](https://dev.epicgames.com/community/learning/talks-and-demos/VlO2/unreal-engine-optimizing-ue5-rethinking-performance-paradigms-for-high-quality-visuals-pt-2-supporting-systems-unreal-fest-2023)

[Designing Visuals, Rendering, and Graphics with Unreal Engine | Unreal Engine 5.4 Documentation | Epic Developer Community (epicgames.com)](https://dev.epicgames.com/documentation/en-us/unreal-engine/designing-visuals-rendering-and-graphics-with-unreal-engine)